Архитектура программного обеспечения (ПО) - это план или структура, описывающая, как система организована, как разные ее части (компоненты) взаимодействуют между собой и с внешними системами. При построении архитектуры используются архитектурные шаблоны, позволяющие использовать наилучшие практики решения архитектурных проблем.
	*Аналогия: Это как план дома, где есть стенки, комнаты, двери и окна, но вместо строй материалов мы работаем с кодом, базами данных и серверами.*

Виды:
1. монолитная архитектура;
2. микросервисная архитектура;
3. сервис-ориентированная архитектура (SOA);
4. клиент-серверная архитектура;
5. событийно-ориентированная архитектура (Event-driven architecture);
6. другие альтернативы.
### ==Монолитная архитектура==

Монолитная архитектура - это традиционная модель ПО, которая представляет собой единый централизованный модуль, работающий автономно и независимо от других приложений. 

Это отдельная большая вычислительная сеть, приложение, с единой базой кода, в которой объединены все бизнес-задачи, все части взаимодействуют прямо друг с другом (база данных, бизнес-логика и пользовательский интерфейс). Взаимодействие с сервисом при этом происходит через API или веб-интерфейс. 

Чтобы внести изменения в такое приложение, необходимо обновить весь стек через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени.
##### Шаблон "Слои (Layers)"
Этот шаблон разделяет систему на несколько слоев, где каждый слой отвечает за определенную функциональность:
- **презентационный слой** (интерфейс пользователя);
- **логический слой** (бизнес-логика);    
- **слой доступа к данным** (работа с базой данных).

![[монолит.png]]
#### Преимущества:
- простое развертывание (использование одного исполняемого файла или каталога);
- разработка легче (использование одной базы кода);
- производительность (один интерфейс API часто может выполнять ту функцию, которую при работе с микросервисами выполняют многочисленные API);
- упрощенное тестирование (сквозное тестирование можно проводить быстрее, чем при использовании распределенного приложения);  
- удобная отладка (весь код в одном месте, легче выполнять запросы и находить проблемы).
#### Недостатки:
- снижение скорости разработки;
- невозможность масштабирования отдельных компонентов;
- надежность (ошибка в одном модуле может повлиять на доступность всего приложения);
- любые изменения в инфраструктуре или языке разработки влияют на приложение целиком, что зачастую приводит к увеличению стоимости и временных затрат;
- недостаточная гибкость, отсутствие выбора технологий;
- развертывание (при внесении небольшого изменения потребуется повторное развертывание всего монолитного приложения).
### ==Микросервисная архитектура==

Микросервисная архитектура - метод организации архитектуры, основанный на ряде независимо развертываемых служб. Система разделяется на набор мелких автономных частей (микросервисы), где каждая из них выполняет отдельную функцию (у каждой собственная кодовая база, бизнес-логика и база данных с конкретной целью), они функционируют независимо друг от друга. 

Каждый компонент самостоятелен и представляет собой отдельное приложение, внутри которого выполняются обновление, тестирование, развертывание и масштабирование. Эти части взаимодействуют между собой через специальные протоколы (например, через [[API]]) или очереди сообщений, таких как RabbitMQ, Kafka или [[Redis]].

Внедрение микросервисов зачастую тесно связано с DevOps, поскольку они лежат в основе методики непрерывной поставки, которая позволяет командам быстро адаптироваться к требованиям пользователей.
##### Шаблон "Gateway/Facade" (Шлюз/Фасад)
В этом шаблоне единый шлюз (API Gateway) отвечает за взаимодействие между клиентом и набором микросервисов. Клиент не обращается к микросервисам напрямую, а использует шлюз, распределяющий запросы.
##### Шаблон "Database per Service" (Отдельная база данных для каждого сервиса)
Каждый микросервис имеет свою базу данных и отвечает за свой набор данных.

![[микросервис.png]]
#### Компоненты микросервисной архитектуры:
- микросервисы - набор автономных сервисов, каждый из которых отвечает за выполнение одной бизнес-функции. Микросервисы взаимодействуют друг с другом через [[API]], используя протоколы [[HTTP]]/REST или [[брокер и очередь сообщений]];
- API Gateway - служит единой точкой входа для всех запросов к микросервисам. Он маршрутизирует запросы к соответствующим микросервисам, управляет аутентификацией и авторизацией, а также выполняет другие задачи, связанные с ограничением скорости и балансировкой нагрузки;   
- Discovery - механизм, позволяющий микросервисам находить друг друга в сети. Сервис Discovery отслеживает расположение и статус всех микросервисов;    
- [[балансировщик нагрузки]] - сервис или программа, которая распределяет входящие запросы между экземплярами микросервисов для обеспечения высокой доступности и масштабируемости;
- хранилище данных - каждый микросервис управляет своей собственной [[база данных]] или хранилищем данных, что обеспечивает децентрализованное управление;
- [[брокер и очередь сообщений]] (Message Broker) - ПО, которое обеспечивает асинхронное взаимодействие между микросервисами, позволяя им обмениваться сообщениями и событиями;
- инструменты для мониторинга и логирования - помогают отслеживать состояние, производительность и логи каждого микросервиса.
#### Преимущества:
- гибкое масштабирование (когда микросервис достигает предельной нагрузки, можно быстро выполнить развертывание новых экземпляров данной службы в сопутствующем кластере и снизить нагрузку);
- гибкость технологий;
- высокая скорость разработки и внедрения нового функционала;
- непрерывное и независимое развертывание микросервисов;
- легкость обслуживания и тестирования (можно экспериментировать с новыми функциями и возвращаться к предыдущей версии, если что-то не работает);
- высокая надежность, так как развертываются изменения для конкретной службы;
- разделение на команды разработки по микросервисам.
#### Недостатки:
- микросервисы усложняют разработку по сравнению с монолитной архитектурой, поскольку в различных местах возникает все больше служб, созданных несколькими командами;
- экспоненциальный рост расходов на инфраструктуру и дополнительные организационные расходы;
- проблемы при отладке (у каждого микросервиса свой набор журналов, что усложняет отладку);
- отсутствие стандартизации;
- отсутствие ясности в вопросах владения и поддержки отдельных микросервисов.
### ==Сервис-ориентированная архитектура (SOA)==

Сервис-ориентированная архитектура - это архитектурный стиль, при котором функции приложения предоставляются в виде независимых сервисов. Эти сервисы могут взаимодействовать друг с другом через стандартизированные интерфейсы и протоколы. Основная цель SOA - обеспечить возможность повторного использования и гибкость в разработке и интеграции программных компонентов.

SOA ориентирована на крупные сервисы с обширной бизнес-логикой, в отличие от микросервисной архитектуры, в которой мелкие сервисы, каждый из которых выполняет свою функцию.
##### Шаблон "Service Registry" (Реетр сервисов)
Этот шаблон подразумевает наличие центрального каталога, в котором хранятся все доступные сервисы. Системы могут обращаться в реестр, чтобы найти нужный сервис.

![[сервис-ориентированная.png]]
#### Ключевые характеристики:
- автономность сервисов - каждый сервис является независимым и может функционировать без вмешательства других сервисов;
- переиспользуемость сервисов повторно в различных приложениях и контекстах;
- взаимодействия между сервисами осуществляется через стандартизированные интерфейсы и протоколы (контракты), такие как SOAP и REST;
- интероперабельность - сервисы могут работать на различных платформах и быть написаны на разных языках программирования.
#### Компоненты сервис-ориентированной архитектуры
- сервисы - основные строительные блоки SOA, каждый из которых представляет собой автономную функциональную единицу, которая предоставляет определенные возможности или данные (бизнес-сервисы, инфраструктурные сервисы и композитные сервисы, которые объединяют несколько других сервисов для выполнения более сложных задач);
- потребители сервисов - приложения или другие сервисы, которые используют функциональность, предоставляемую сервисами, взаимодействуют с сервисами через стандартизированные интерфейсы и протоколы (веб-приложения, мобильные приложения, другие бизнес-сервисы или внешние системы);
- корпоративная сервисная шина (ESB) - обеспечивает взаимодействие между сервисами, выполняет функции маршрутизации сообщений, трансформации данных, оркестрации сервисов и управления интеграцией, обеспечивает надежную доставку сообщений и управление транзакциями;
- репозиторий сервисов - хранит метаданные о сервисах, такие как их описания, контракты, схемы и политики, для поиска и повторного использования существующих сервисов. Управляет версиями сервисов, отслеживает их зависимости и обеспечивает соответствие стандартам и политикам;
- управление и мониторинг - обеспечивают контроль за состоянием и производительностью сервисов, а также управляют конфигурацией.
#### Преимущества:
- повторное использование сервисов благодаря стандартизированным контрактам;
- централизованное управление и контроль через ESB;
- подходит для крупномасштабных корпоративных систем с комплексными интеграциями.
#### Недостатки:
- сложность и стоимость внедрения, а также поддержки ESB;
- медленная реакция на изменения из-за крупнозернистости сервисов;
- возможные узкие места и точки отказа ESB.
### ==Клиент-серверная архитектура==

Клиент-серверная архитектура - это архитектура, в которой задачи или сетевая нагрузка распределены между клиентами и серверами. Она подразумевает чёткое распределение ролей: клиент инициирует запросы на услуги или ресурсы у сервера, предоставляет интерфейс пользователю, а сервер обрабатывает запросы, предоставляет ресурсы, данные и услуги.
##### Шаблон "Proxy" (Прокси-сервер)
Прокси - это промежуточный сервер, который принимает запросы от клиента и передает их на сервер. Прокси может кэшировать ответы или контролировать доступ.

![[клиент-сервер.png]]
#### Компоненты клиент-серверной архитектуры:
- клиент - приложение или устройство, которое запрашивает услугу или ресурс у сервера. Клиенты - обычно это то, что видит пользователь: программные приложения (веб-браузеры, мобильные приложения), аппаратные устройства (смартфоны, планшеты, терминалы, так называемые «тонкие клиенты»);
- сервер - удалённый компьютер или система, которая предоставляет запрашиваемую информацию или услуги клиентам. Серверы выполняет основную логику, различные функции, такие как хранение данных, обработка запросов, вычисления и т. п.;
- протоколы обмена данными - правила или наборы инструкций, которые определяют, как клиенты и серверы обмениваются информацией. [[HTTP]]/HTTPS (гипертекстовые протоколы), стек протоколов TCP/IP (набор правил, описывающих, как компьютеры соединяются и передают информацию друг другу), протоколы отправки и получения почты (SMTP, POP3, IMAP);
- [[база данных]] - структурированное хранилище информации, которое используется на серверной стороне для хранения и управления данными. Базы данных позволяют серверу эффективно хранить, организовывать и извлекать информацию по запросу клиента;
- сеть - инфраструктура, которая обеспечивает связь между клиентами и серверами. Локальные (LAN) и глобальные (WAN) сети. Сеть обеспечивает передачу данных между клиентами и серверами по протоколам обмена данными;
- [[балансировщик нагрузки]] - сервис или программа, которая распределяет входящие запросы между группой серверов, в каждом случае возвращая ответ от выбранного сервера соответствующему клиенту (для обеспечения отказоустойчивости, высокой доступности и оптимизации производительности);
- [[брокер и очередь сообщений]] - ПО, которое управляет обменом сообщениями между приложениями, сервисами или системами;
- система безопасности - это компонент, который обеспечивает защиту данных, передаваемых между клиентами и серверами (шифрование данных, аутентификацию и авторизацию клиентов, защиту от несанкционированного доступа и др.);
- хранение и обработка данных - это компоненты, связанные с хранением данных на серверах и их обработкой (серверные ОС, СУБД, серверы приложений и др.).
#### Процесс:
1. запрос клиента - пользователь запускает ресурс, инициируя запрос к серверу, который может содержать какие-то данные, авторизационную информацию или команду;
2. отправка запроса - ресурс формирует запрос и направляет его на адрес сервера по определённому протоколу связи (обычно [[HTTP]]);
3. приём запроса сервером - после получения запроса сервер проверяет его валидность, аутентичность и определяет необходимые действия;
4. обработка запроса - проведение сервером соответствующих операций (выборка данных из [[база данных]], вычисления, генерация страницы сайта);  
5. формирование ответа - после обработки запроса сервер создаёт ответ и отправляет его обратно клиенту;
6. получение ответа клиентом и отображение его пользователю, либо сохранение полученных данных;
7. повторение цикла при каждом взаимодействии пользователя с системой.
#### Преимущества:
- масштабируемость, так как позволяет распределить нагрузку на сервера;
- централизованное управление (сервер является центральным узлом, который контролирует всю систему, обеспечивает безопасность и управление доступом к данным);
- надежность (отказ одного компонента системы не влияет на работу других компонентов);
- безопасность (централизованное управление сервером обеспечивает возможность контроля доступа и защиты данных).
#### Недостатки:
- зависимость от сервера - клиент не может работать без сервера;
- затраты на инфраструктуру;
- зависимость от сети;
- ограниченность (возникают ограничения на количество одновременно подключенных клиентов и на пропускную способность сети).

### ==Событийно-ориентированная архитектура (Event-driven architecture)==

Событийно-ориентированная - это концепция программирования, которая позволяет создавать сложные приложения, используя событийно-ориентированный подход. Основная идея заключается в том, что все действия в приложении основаны на событиях - маленьких отправляемых сообщений, когда что-то происходит в системе. Это позволяет создавать распределенные системы, которые легко масштабируются и обладают высокой отказоустойчивостью.  

Основной принцип - это разделение системы на независимые компоненты (сервисы), которые общаются между собой через события. Каждый компонент обрабатывает только те события, которые ему нужны, что позволяет создавать независимые, легковесные компоненты, которые можно размещать на разных серверах, при этом компоненты могут быть связаны вместе и работать в офлайн режиме.

Один из примеров использования event-driven архитектуры в бэкенде - это создание асинхронных приложений, которые позволяют параллельно выполнять несколько задач. Это помогает улучшить производительность приложения и уменьшить время отклика.

В событийно-ориентированной архитектуре приложение разделено на независимые компоненты, которые общаются через события, в отличие от традиционной монолитной архитектуре, где все компоненты приложения объединены в единый блок и вы должны использовать один и тот же язык программирования и инструменты для разработки.
##### Шаблон "Event Sourcing" (Источник событий)
В этом шаблоне все изменения в системе представляются в виде событий, записываемых в журнал событий. Это позволяет восстановить текущее состояние системы на основе предыдущих событий.

![[cобытийно-ориентированная.png]]
#### Слои архитектуры:
- генератор событий - регистрирует факт и представляет этот факт событием (клиент электронной почты, система электронной коммерции или некоторый тип датчика;
- канал событий - механизм, по которому передаётся информация от генератора событий к обрабатывающему события механизму или стоку (соединение TCP/IP или входной файл любого типа (простой текст, формат XML, e-mail, и т. д.)). Каналы событий считываются асинхронно. События сохраняются в очереди, ожидая последующей обработки механизмом обработки событий;
- механизм обработки событий (сток) - место, где событие идентифицируется и выбирается соответствующая реакция на него, которая затем выполняется;
- последующее действие, управляемое событиями - последствия события (сообщение, посланное кому-либо, или приложение, выводящее какое-либо предупреждение на экран).
#### Преимущества: 
- высокая отказоустойчивость и гибкость;  
- высокая производительность, поскольку сервисы реагируют на события, только когда они происходят;
- высокая масштабируемость, можно добавлять новые обработчики событий.
#### Недостатки:
- трудность в тестировании и отслеживании всех событий;
- хаос в системе из-за неправильно обработанных событий.
### ==Другие альтернативы==

**Peer-to-peer (P2P)** - децентрализованная сеть, где участники равноправны и самостоятельно обмениваются данными друг с другом без участия центрального сервера. Главное преимущество P2P-модели - низкая нагрузка на инфраструктуру и высокая отказоустойчивость. Но это решение подходит не каждому типу сервисов и ограничивает применение там, где необходима строгая централизация данных. Примеры: Skype и BitTorrent.

**Edge computing** - размещение вычислительных ресурсов ближе к источникам данных и пользователям. Таким образом, большая часть обработки данных происходит на устройствах клиентов. Эта технология активно применяется в IoT-девайсах, в системах умного дома и облачных сервисах.

**Serverless architecture** - разработка ведётся с применением облаков и провайдеров, которые берут на себя всю техническую сторону обслуживания серверов. Разработчики пишут небольшие функциональные части кода (функции), которые выполняются автоматически при срабатывании соответствующих триггеров.
