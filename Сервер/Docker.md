#### ==Общая информация==

**Docker** - это платформа, которая позволяет упаковать в изолированный контейнер приложение со всем окружением и зависимостями, а затем доставить и запустить его в целевой системе.

**Контейнер** - изолированная среда для запуска приложений со всеми необходимыми зависимостями, это абстракция на уровне приложения. Это легковесные, изолированные среды выполнения, внутри которых работают приложения.

В отличие от виртуальных машин, контейнеры используют общее ядро ОС, что делает их менее затратными с точки зрения ресурсов. Это позволяет запускать больше контейнеров на одном сервере по сравнению с количеством виртуальных машин.

Преимущества контейнеров:
- изоляция;
- эффективное использование ресурсов (контейнеры легче ВМ, используют общее ядро ОС);
- повторяемость (работает на разных устройствах);
- простота доставки (перенос между различными окружениями).

Контейнер - это запущенный экземпляр образа (контейнеры создаются на основе образов).

**Образ Docker** - это статичное описание содержимого контейнера, включающее в себя все зависимости, настройки окружения, библиотеки и бинарные файлы, необходимые для выполнения приложения (шаблон для создания контейнеров). Образы описываются с помощью Dockerfile. 

**Dockerfile** - это текстовый файл специального формата, содержащий команды для сборки Docker-образа. Эти команды описывают шаги, необходимые для установки зависимостей и конфигурации вашего приложения с учетом контекста приложения. В нем последовательно указываются базовый образ, необходимые зависимости, действия по копированию файлов и команда запуска приложения.

*Пример Dockerfile:*
```dockerfile
# Указываем базовый образ
FROM python:3.11-slim
# Устанавливаем рабочую директорию внутри будущего контейнера
WORKDIR /app
# Копируем файлы приложения (с хоста (контекст) в образ (/app))
COPY . /app
# Устанавливаем зависимости
RUN pip install --no-cache-dir fastapi uvicorn psycopg2-binary python-dotenv
# Запускаем приложение
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

---
#### ==Ключевые команды==

##### Работа с образами (Images)
```bash
# Просмотр списка образов
docker images (docker image ls)

# Загрузка образа из Docker Hub (тег указывает конкретную версию)
docker pull <имя_образа>:<тег> 

# Удаление образа (с флагом -f принудительное)
docker rmi -f <ID_образа_или_имя:тег>

# Удаление всех неиспользуемых образов
docker image prune -a

# Просмотр истории образа
docker history <имя_образа>:<тег>

# Получение подробной информации об образе
docker inspect <имя_образа>:<тег>
```
##### Работа с контейнерами (Containers)
```bash
# Просмотр запущенных контейнеров (флаг -a для всех контейнеров)
docker ps

# Запуск нового контейнера в фоновом режиме
docker run -d <ИМЯ_ОБРАЗА> [КОМАНДА] [АРГУМЕНТЫ...]

# Запуск остановленного контейнера
docker start <ID_контейнера_или_имя>

# Остановка работающего контейнера
docker stop <ID_контейнера_или_имя>

# Перезапуск контейнера
docker restart <ID_контейнера_или_имя>

# Принудительное удаление остановленного контейнера
docker rm <ID_контейнера_или_имя>

# Удаление всех остановленных контейнеров
docker container prune

# Просмотр логов контейнера
docker logs <ID_контейнера_или_имя>

# Просмотр логов контейнера в реальном времени
docker logs -f <ID_контейнера_или_имя>

# Выполнение команд внутри работающего контейнера (подключиться к БД, запустить shell, копирование файлов между хостом и контейнером)
docker exec -it <ID_контейнера_или_имя> <команда>

# Получение подробной информации о контейнере
docker inspect <ID_контейнера_или_имя>
```
##### Сборка образов с помощью Dockerfile
```bash
# Создание Docker-образа на основе инструкций из файла Dockerfile
docker build [флаг] <ПУТЬ_К_КОНТЕКСТУ_СБОРКИ>

# -t <имя>:<тег>: задает имя и тег для создаваемого образа;
# -f <путь_к_Dockerfile>: указывает путь к файлу Dockerfile, если он называется иначе или находится не в корне контекста сборки;
# --no-cache: собирает образ без использования кеша слоев. Полезно, если кеш приводит к неожиданному поведению.
```
##### Управление многоконтейнерными приложениями с Docker Compose
```bash
# Cборка, создание и запуск всех сервисов, описанных в docker-compose.yml
# -d: запустить сервисы в фоновом режиме;
# --build: принудительно пересобрать образы перед запуском сервисов;
# --force-recreate: пересоздать контейнеры, даже если их конфигурация или образ не изменились.
docker-compose up

# Остановка и удаление контейнеров, созданных командой up
# -v: удалить также именованные тома, связанные с сервисами.
docker-compose down

# Статус запущенных контейнеров (флаг -a для всех контейнеров)
docker-compose ps

# Логи для указанного сервиса или для всех сервисов, если имя не указано
docker-compose logs [имя_сервиса]

# Выполнение команды в работающем контейнере указанного сервиса
docker-compose exec <имя_сервиса> <команда>

# Сборка или пересборка образов для сервисов
docker-compose build [имя_сервиса]

# Проверка скомпилированной конфигурации Compose
docker-compose config

# Загрузка образов для сервисов
docker-compose pull [имя_сервиса]

# Перезапуск сервисов
docker-compose restart [имя_сервиса]

# Остановка сервисов без их удаления
docker-compose stop [имя_сервиса]

# Запуск ранее остановленных сервисов
docker-compose start [имя_сервиса]
```
##### Управление сетями
```bash
# Список всех сетей
docker network ls 

# Создание новой сети (по умолчанию типа bridge)
docker network create <имя_сети>

# Удаление сети
docker network rm <имя_сети>

# Отображение подробной информации о сети, включая подключенные к ней контейнеры
docker network inspect <имя_сети>

# Подключение работающего контейнера к указанной сети
docker network connect <имя_сети> <имя_контейнера>

# Отключение контейнера от сети
docker network disconnect <имя_сети> <имя_контейнера>
```
##### Управление томами
```bash
# Список всех томов
docker volume ls

# Создание нового именованного тома
docker volume create <имя_тома>

# Удаление тома (потеря всех данных в томе)
docker volume rm <имя_тома>

# Отображение подробной информации о томе
docker volume inspect <имя_тома>

# Удаление всех бесхозных томов (тех, что не используются ни одним контейнером)
docker volume prune
```

---
##### ==Сети==

Работа с сетями - это одна из ключевых составляющих контейнеризации в Docker. Отсутствие настройки сетевого взаимодействия контейнеров может привести к проблемам с доступом к вашим сервисам.

Docker предоставляет несколько драйверов сетевого взаимодействия, из которых наиболее распространённые - bridge, host и overlay.

- **Bridge**
	Этот сетевой режим используется по умолчанию. В нем создается виртуальный мост (bridge), который позволяет контейнерам общаться друг с другом и с хост-машиной. При запуске контейнера создается виртуальный интерфейс и подключается к мосту, предоставляя контейнерам IP-адреса из определенного диапазона. Bridge-сеть позволяет изолировать контейнеры от других сетевых интерфейсов хост-машины.
	Для подключения контейнера к сети, укажите имя сети при запуске контейнера с использованием флага --network.

```bash
docker network create --driver bridge app_network
docker run -d --network app_network --name app nginx
```

- **Host**
	В этом режиме контейнер использует сетевой стек хост-машины. Это означает, что контейнер и хост имеют общий IP-адрес и порты. Host-сеть полезна для уменьшения сетевой задержки, однако она уменьшает изоляцию между контейнером и хостом.

```bash
docker run -d --network host nginx
```

- **Overlay**
	Этот режим в основном используется в кластерных средах и Docker Swarm.
	Overlay-сети позволяют контейнерам, работающим на разных физических или виртуальных машинах, общаться друг с другом так, будто они находятся на одной сети. Это достигается путем создания распределенной сети поверх существующей физической инфраструктуры. 

---
##### ==Docker Volumes и связывание контейнера с файловой системой хоста (bind mounts)==

**Volumes и bind mount**s - два ключевых механизма для работы с данными в контейнерах. Они необходимы, чтобы эффективно управлять данными, обеспечивать их сохранность и доступность.
- Docker volumes (Тома) существуют, чтобы хранить данные отдельно от контейнера. Даже в случае, если контейнер удалится, данные, хранящиеся в volume, останутся нетронутыми, что важно, когда проект уже развернут на площадке. Они управляются Docker и существуют независимо от жизненного цикла контейнера;
- Bind Mounts немного отличаются от volumes. Этот подход представляет собой простое монтирование директорий с хоста в директории внутри контейнера. Это позволяет контейнерам иметь прямой доступ к данным на хосте, что удобно для среды разработки и тестирования. При использовании bind mounts, Docker не управляет содержимым целевой директории. Это означает, что изменения, внесенные в файлы на хосте, будут немедленно отражаться внутри контейнера, и наоборот.

---
##### ==Docker Compose==

**Docker Compose** - это мощный инструмент, разработанный для упрощения работы с многоконтейнерными приложениями. Он позволяет вам описать и запустить сложные приложения, состоящие из нескольких контейнеров, с минимальными усилиями.

Основные возможности Docker Compose включают:
- декларативное описание сервисов, volumes и networks в формате yaml;
- управление всеми службами, указанными в конфигурационном файле, при помощи единой утилиты docker compose;
- управление жизненным циклом контейнеров.

*Пример docker-compose.yml:*
```yaml
services:
  postgres:
    image: postgres:15
    container_name: postgres
    env_file: .env
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
  
  client_backend:
    build: ./client/backend
    container_name: client_backend
    volumes:
      - ./client/backend:/app
    env_file:
      - .env
    depends_on:
      - postgres
  
  client_frontend:
    build: ./client/frontend
    container_name: client_frontend
    volumes:
      - ./client/frontend:/app
    stdin_open: true
    tty: true
  
  staff_backend:
    build: ./staff/backend
    container_name: staff_backend
    volumes:
      - ./staff/backend:/app
    env_file:
      - .env
    depends_on:
      - postgres

  staff_frontend:
    build: ./staff/frontend
    container_name: staff_frontend
    volumes:
      - ./staff/frontend:/app
    stdin_open: true
    tty: true

  nginx:
    image: nginx:latest
    container_name: nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
      - ./admin-client/frontend/build:/var/www/client
      - ./admin-staff/frontend/build:/var/www/staff
    depends_on:
      - client_frontend
      - staff_frontend

  certbot:
    image: certbot/certbot
    container_name: certbot
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    entrypoint: /bin/sh -c "trap exit TERM; while :; do sleep 1 & wait $${!}; done"

volumes:
  pgdata:
```
###### services:
Определяет список сервисов (контейнеров), которые будут создаваться и запускаться через Docker Compose.
###### postgres:
- `image: postgres:15` - используется официальный образ PostgreSQL версии 15.
- `container_name: postgres` - имя запускаемого контейнера будет `postgres`.
- `env_file: .env` - загружает переменные окружения из файла `.env` для конфигурации PostgreSQL (пароли, параметры).
- `ports: ["5432:5432"]` - маппинг порта порта 5432 контейнера на порт 5432 хоста (чтобы база была доступна снаружи). Если база **только для сервера**, не надо делать порт доступным наружу (для postgres 5432:5432 <- убрать)
- `volumes: [pgdata:/var/lib/postgresql/data]` - сохраняет данные базы (папка с данными внутри контейнера) в персистентный volume `pgdata`, чтобы данные не терялись при пересоздании контейнера.
###### client_backend:
- `build: ./client/backend` - собирает образ из Dockerfile в каталоге `./client/backend`.
- `container_name: client_backend` - имя контейнера.
- `volumes: ["./client/backend:/app"]` - монтирует локальную папку `./client/backend` внутрь контейнера в `/app`, для live-редактирования кода.
- `env_file: [.env]` - загружает переменные окружения из `.env`.
- `depends_on: ["postgres"]` - сервис запускается после запуска контейнера `postgres`, чтобы база была готова.
###### client_frontend:
- `build: ./client/frontend` - собирает образ фронтенда из `./client/frontend`.
- `container_name: client_frontend` - имя контейнера.
- `volumes: ["./client/frontend:/app"]` - монтирует локальную папку фронтенда в контейнер.
- `stdin_open: true` и `tty: true` - позволяют открыть интерактивный терминал для контейнера (может быть полезно для отладки).
###### staff_backend:
- Аналогично `client_backend`: сборка из `./staff/backend`, подключение .env, зависит от PostgreSQL.
###### staff_frontend:
- Аналогично `client_frontend`, код монтируется код с `./staff/frontend`. Аналогичные настройки для интерактивного режима.
###### nginx:
- `image: nginx:latest` - использует официальный последний образ [[Nginx]].
- `container_name: nginx` - имя контейнера.
- `ports: ["80:80", "443:443"]` - публикует HTTP и HTTPS порты из контейнера на хост.
- `volumes:` - монтирует конфигурационный файл nginx из локальной папки в контейнер, сертификаты Let's Encrypt, каталоги для веб-ресурсов (`/var/www/client`, `/var/www/staff`).
- `depends_on: ["client_frontend", "staff_frontend"]` - запускается после фронтенд-контейнеров.
###### certbot:
- `image: certbot/certbot` - официальный образ [[Certbot]] (для автоматического управления SSL сертификатами).
- `container_name: certbot`.
- `volumes:` - монтирует директории для сертификатов и вызовов ACME (для подтверждения домена).
- `entrypoint:` - поддерживает контейнер в постоянном "онлайн" режиме (цикл сна) для работы certbot.
###### volumes:
Определяет именованные тома Docker, которые используются для хранения данных вне контейнеров (персистентное хранение).
- `pgdata:` - название тома, подключаемого к PostgreSQL для данных.
